{"metadata":{"title":"BigDecimal","symbolKind":"module","role":"collection","externalID":"BigDecimal","roleHeading":"Framework","modules":[{"name":"BigDecimal"}]},"kind":"symbol","sections":[],"abstract":[{"type":"text","text":"The BigDecimal package provides arbitrary-precision (with an adjustable upper"},{"text":" ","type":"text"},{"text":"limit for performance) and fixed-precision decimal arithmetic in Swift.","type":"text"}],"topicSections":[{"generated":true,"identifiers":["doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/DecimalFloatingPoint","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerIterator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/SeriesCalculator"],"title":"Protocols","anchor":"Protocols"},{"generated":true,"anchor":"Structures","title":"Structures","identifiers":["doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/AsinCalculator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/CosCalculator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/CoshCalculator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal128","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal32","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal64","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/ExpCalculator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerNIterator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerTwoNIterator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerTwoNPlusOneIterator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/RawDecimal","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Rounding","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/SinCalculator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/SinhCalculator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Status"]},{"title":"Type Aliases","generated":true,"identifiers":["doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/CBDecimal","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/IntRange","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/RoundingRule","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Sign"],"anchor":"Type-Aliases"},{"generated":true,"title":"Extended Modules","anchor":"Extended-Modules","identifiers":["doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/ComplexModule","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Swift"]}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/bigdecimal"]}],"hierarchy":{"paths":[[]]},"schemaVersion":{"minor":3,"patch":0,"major":0},"primaryContentSections":[{"kind":"content","content":[{"level":2,"anchor":"overview","text":"Overview","type":"heading"},{"inlineContent":[{"type":"text","text":"Its functionality falls in the following categories:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Arithmetic: addition, subtraction, multiplication, division, remainder and","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"exponentiation"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Compliant with ","type":"text"},{"type":"codeVoice","code":"DecimalFloatingPoint"},{"type":"text","text":" and, optionally, "},{"code":"Real","type":"codeVoice"},{"text":" protocols.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Support for complex decimal numbers via ","type":"text"},{"type":"codeVoice","code":"swift-numerics"},{"type":"text","text":" if "},{"code":"Real","type":"codeVoice"},{"text":" protocol","type":"text"},{"type":"text","text":" "},{"text":"compliance is enabled.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Constants: "},{"type":"codeVoice","code":"pi"},{"text":", ","type":"text"},{"type":"codeVoice","code":"zero"},{"text":", ","type":"text"},{"type":"codeVoice","code":"one"},{"type":"text","text":", "},{"code":"ten","type":"codeVoice"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Functions: exp, log, log10, log2, pow, sqrt, root, factorial, gamma,"},{"type":"text","text":" "},{"type":"text","text":"trig + inverse, hyperbolic + inverse"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Rounding and scaling according to one of the rounding modes:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"awayFromZero"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"down"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"towardZero","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"toNearestOrEven"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"toNearestOrAwayFromZero"}]}]},{"content":[{"inlineContent":[{"text":"up","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"Comparison: the six standard operators ","type":"text"},{"type":"codeVoice","code":"=="},{"type":"text","text":", "},{"type":"codeVoice","code":"!="},{"type":"text","text":", "},{"code":"<","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"<="},{"type":"text","text":", "},{"type":"codeVoice","code":">"},{"type":"text","text":", and "},{"type":"codeVoice","code":">="}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Conversion: to String, to Double, to Decimal (the Swift Foundation type), to","type":"text"},{"type":"text","text":" "},{"text":"Decimal32 \/ Decimal64 \/ Decimal128","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Support for Decimal32, Decimal64 and Decimal128 values stored as UInt32,"},{"type":"text","text":" "},{"type":"text","text":"UInt64 and UInt128 values respectively, using Densely Packed Decimal (DPD)"},{"text":" ","type":"text"},{"type":"text","text":"encoding or Binary Integer Decimal (BID) encoding"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Support for Decimal32, Decimal64 and Decimal128 mathematical operations"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Supports the IEEE 754 concepts of Infinity and NaN (Not a Number) with the"},{"text":" ","type":"text"},{"text":"latter having a ","type":"text"},{"type":"codeVoice","code":"signaling"},{"text":" option.","type":"text"}]}]}]},{"text":"Dependencies","type":"heading","level":2,"anchor":"Dependencies"},{"type":"paragraph","inlineContent":[{"text":"BigDecimal requires Swift from macOS 13.3+, iOS 16.4+, macCatalyst 16.4+,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"tvOS 16.4+, or watchOS 9.4+. It also requires that the "},{"type":"codeVoice","code":"Int"},{"text":" type be a 64-bit","type":"text"},{"text":" ","type":"text"},{"text":"type.","type":"text"}]},{"inlineContent":[{"type":"text","text":"The BigDecimal package depends on the BigInt and UInt128 packages."}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["dependencies: [","  .package(url: \"https:\/\/github.com\/mgriebling\/BigInt.git\", from: \"2.0.0\"),","  .package(url: \"https:\/\/github.com\/mgriebling\/UInt128.git\", from: \"3.0.0\")","]"]},{"type":"heading","anchor":"Usage","text":"Usage","level":2},{"type":"paragraph","inlineContent":[{"text":"In your project’s Package.swift file add a dependency like","type":"text"}]},{"code":["dependencies: [","  .package(url: \"https:\/\/github.com\/mgriebling\/BigDecimal.git\", from: \"2.0.0\"),","]"],"type":"codeListing","syntax":null},{"level":2,"type":"heading","text":"Basics","anchor":"Basics"},{"text":"Creating BigDecimal’s","level":3,"type":"heading","anchor":"Creating-BigDecimals"},{"type":"codeListing","code":["\/\/ From an integer","let x1 = BigDecimal(270) \/\/ = 270","let x2 = BigDecimal(270, -2)  \/\/ = 2.70","let x3 = BigDecimal(314159265, -8) \/\/ = 3.14159265","  ","\/\/ From a BInt","let x4 = BigDecimal(BInt(314159265), -8) \/\/ = 3.14159265","let x5 = BigDecimal(BInt(100), -3) \/\/ = 0.100","  ","\/\/ From a string literal","let rnd1 = Rounding(.halfEven, 2)","let x6 = BigDecimal(\"0.123\").round(rnd1) \/\/ = 0.12","let x7 = BigDecimal(\"3.14159265\") \/\/ = 3.14159265","  ","\/\/ From a double","let rnd2 = Rounding(.halfEven, 9)","let x8 = BigDecimal(0.1).round(rnd2)  \/\/ = 0.100000000","let x9 = BigDecimal(0.1) \/\/ = 0.1000000000000000055511151231257827021181583404541015625","let x10 = BigDecimal(3.14159265) \/\/ = 3.141592650000000208621031561051495373249053955078125","let x11 = BigDecimal(3.14159265).round(rnd2) \/\/ = 3.14159265","","\/\/ From Decimal32 \/ 64 \/ 128 encoded values","let x32 = BigDecimal(UInt32(0x223000f0), .dpd) \/\/ = 1.70","let x64 = BigDecimal(UInt64(0x22300000000000f0), .dpd) \/\/ = 1.70","let x128 = BigDecimal(UInt128(0x2207800000000000, 0x00000000000000f0), .dpd) \/\/ = 1.70"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because Double values cannot represent all decimal values exactly,"},{"text":" ","type":"text"},{"type":"text","text":"one sees that BigDecimal(0.1) is not exactly equal to 1 \/ 10 as one might expect."},{"type":"text","text":" "},{"type":"text","text":"On the other hand, BigDecimal(“0.1”) is in fact exactly equal to 1 \/ 10."}]},{"level":3,"text":"Converting BigDecimal’s","type":"heading","anchor":"Converting-BigDecimals"},{"inlineContent":[{"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal","isActive":true},{"text":" values can be converted to ","type":"text"},{"code":"String","type":"codeVoice"},{"type":"text","text":" values, "},{"code":"Double","type":"codeVoice"},{"text":" values,","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"Decimal"},{"type":"text","text":" (the Swift Foundation type) values, and "},{"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal32","isActive":true},{"text":", ","type":"text"},{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal64","type":"reference","isActive":true},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and "},{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal128","isActive":true,"type":"reference"},{"text":" values.","type":"text"}],"type":"paragraph"},{"level":4,"text":"To String","type":"heading","anchor":"To-String"},{"code":["let x1 = BigDecimal(\"2.1\").pow(3)","print(x1.asString()) \/\/ = 9.261"],"syntax":"swift","type":"codeListing"},{"anchor":"To-Double","level":4,"text":"To Double","type":"heading"},{"type":"codeListing","syntax":"swift","code":["let x2 = BigDecimal(\"2.1\").pow(3)","print(x2.asDouble()) \/\/ = 9.261"]},{"text":"To Decimal (the Swift Foundation type)","level":4,"anchor":"To-Decimal-the-Swift-Foundation-type","type":"heading"},{"syntax":"swift","type":"codeListing","code":["let x3 = BigDecimal(\"1.70\")","let xd: Decimal = x3.asDecimal()","print(xd) \/\/ = 1.70"]},{"type":"heading","anchor":"To-Decimal32--64--128","level":4,"text":"To Decimal32 \/ 64 \/ 128"},{"type":"codeListing","code":["let x4 = BigDecimal(\"1.70\")","let x32: UInt32 = x4.asDecimal32(.dpd)","let x64: UInt64 = x4.asDecimal64(.dpd)","let x128: UInt128 = x4.asDecimal128(.dpd)","print(String(x32, radix: 16))  \/\/ = 223000f0","print(String(x64, radix: 16))  \/\/ = 22300000000000f0","print(String(x128, radix: 16)) \/\/ = 220780000000000000000000000000f0"],"syntax":"swift"},{"level":3,"type":"heading","anchor":"Comparing-BigDecimals","text":"Comparing BigDecimal’s"},{"inlineContent":[{"text":"The six standard operators == != < <= > >= are available to compare values.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The two operands may either be two "},{"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal","isActive":true},{"type":"text","text":"’s or a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal"},{"type":"text","text":" and"},{"text":" ","type":"text"},{"type":"text","text":"an integer. If neither of the operands is NaN, the operators perform as expected."},{"type":"text","text":" "},{"type":"text","text":"For example, -"},{"isActive":true,"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/infinity"},{"type":"text","text":" is less than any finite number which in"},{"text":" ","type":"text"},{"type":"text","text":"turn is less than +"},{"isActive":true,"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/infinity","type":"reference"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Please see the section "},{"type":"emphasis","inlineContent":[{"text":"About NaN’s","type":"text"}]},{"type":"text","text":" for the rules governing comparison involving NaN’s."}]},{"inlineContent":[{"text":"The static function ","type":"text"},{"type":"codeVoice","code":"BigDecimal.maximum(x:y:)"},{"text":" returns the non-NaN number if","type":"text"},{"type":"text","text":" "},{"type":"text","text":"either x or y is NaN; otherwise it returns the larger of x and y."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The static function "},{"code":"BigDecimal.minimum(x:y:)","type":"codeVoice"},{"text":" returns the non-NaN number if","type":"text"},{"type":"text","text":" "},{"type":"text","text":"either x or y is NaN; otherwise it returns the smaller of x and y."}]},{"anchor":"Exact-Arithmetic","level":3,"text":"Exact Arithmetic","type":"heading"},{"inlineContent":[{"text":"The ‘+’, ‘-’, and ‘*’ operators always produce exact results. The ‘\/’ operator","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"truncates the exact result to an integer."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let a = BigDecimal(\"25.1\")","let b = BigDecimal(\"12.0041\")","","print(a + b) \/\/ = 37.1041","print(a - b) \/\/ = 13.0959","print(a * b) \/\/ = 301.30291","print(a \/ b) \/\/ = 2"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"text":"quotientAndRemainder","type":"text"}],"type":"emphasis"},{"type":"text","text":" function produces an integer quotient and exact remainder"}]},{"syntax":"swift","code":["print(a.quotientAndRemainder(b)) \/\/ = (quotient: 2, remainder: 1.0918)"],"type":"codeListing"},{"level":3,"text":"Rounded Arithmetic","anchor":"Rounded-Arithmetic","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Rounding is controlled by Rounding objects that contain a rounding mode and a","type":"text"},{"type":"text","text":" "},{"type":"text","text":"precision, which is the number of digits in the rounded result."}]},{"inlineContent":[{"text":"The rounding modes are:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"awayFromZero - round away from 0","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"down - round towards -infinity"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"up - round towards +infinity"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"towardZero - round towards 0"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"toNearestOrEven - round to nearest, ties to even"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"toNearestOrAwayFromZero - round to nearest, ties away from 0","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"text":"add","type":"text"}]},{"type":"text","text":", "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subtract"}]},{"type":"text","text":" and "},{"inlineContent":[{"type":"text","text":"multiply"}],"type":"emphasis"},{"text":" methods have a Rounding parameter that","type":"text"},{"text":" ","type":"text"},{"text":"controls how the result is rounded.","type":"text"}]},{"text":"Examples","level":4,"anchor":"Examples","type":"heading"},{"syntax":"swift","code":["let a = BigDecimal(\"25.1E-2\")","let b = BigDecimal(\"12.0041E-3\")","let rnd = Rounding(.ceiling, 3)","\t","print(a + b) \/\/ = 0.2630041","print(a.add(b, rnd)) \/\/ = 0.264","print(a - b) \/\/ = 0.2389959","print(a.subtract(b, rnd)) \/\/ = 0.239","print(a * b) \/\/ = 0.0030130291","print(a.multiply(b, rnd)) \/\/ = 0.00302"],"type":"codeListing"},{"anchor":"Precise-division","level":3,"text":"Precise division","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"divide","type":"text"}]},{"text":" method, that has an optional rounding parameter, performs division.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If the quotient has finite decimal expansion, the rounding parameter may or may not be present, it is used if it is there."},{"type":"text","text":" "},{"text":"If the quotient has infinite decimal expansion, the rounding parameter must be present and is used to round the result.","type":"text"}]},{"level":4,"text":"Examples","type":"heading","anchor":"Examples"},{"type":"codeListing","code":["let x1 = BigDecimal(3)","let x2 = BigDecimal(48)","print(x1.divide(x2))  \/\/ = 0.0625","let rnd = Rounding(.ceiling, 2)","print(x1.divide(x2, rnd))  \/\/ = 0.063","\t","let x3 = BigDecimal(3)","let x4 = BigDecimal(49)","print(x3.divide(x4))       \/\/ = NaN because the quotient has infinite decimal expansion 0.06122448...","print(x3.divide(x4, rnd))  \/\/ = 0.062"],"syntax":"swift"},{"type":"heading","text":"Data Encoding","level":2,"anchor":"Data-Encoding"},{"inlineContent":[{"type":"text","text":"BigDecimal’s can be encoded as Data objects (perhaps for long term storage) using the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"asData"}]},{"text":" method,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and they can be regenerated from their Data encoding using the appropriate initializer."},{"text":" ","type":"text"},{"type":"text","text":"The encoding rules are:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"The encoding contains nine or more bytes. The first eight bytes is a","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Big Endian encoding of the signed exponent."},{"type":"text","text":" "},{"type":"text","text":"The remaining bytes is a Big Endian encoding of the signed significand."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"NaN’s (and signaling NaNs) are encoded as a single byte = 0"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"positive infinity is encoded as a single byte = 1","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"negative infinity is encoded as a single byte = 2"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"negative zero is encoded as a single byte = 3","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"It is also possible to encode BigDecimal’s using the ","type":"text"},{"code":"JSONEncoder","type":"codeVoice"},{"type":"text","text":" or as a"},{"text":" ","type":"text"},{"type":"text","text":"property list using the "},{"code":"PropertyListEncoder","type":"codeVoice"},{"type":"text","text":" as in the second example."}]},{"level":3,"anchor":"Examples","text":"Examples","type":"heading"},{"code":["let x1 = BigDecimal(1000, 3) \/\/ = 1000000","print(Bytes(x1.asData()))   \/\/ = [0, 0, 0, 0, 0, 0, 0, 3, 3, 232]","","let x2 = BigDecimal(1000, -3) \/\/ = 1.000","print(Bytes(x2.asData()))   \/\/ = [255, 255, 255, 255, 255, 255, 255, 253, 3, 232]","","let x3 = BigDecimal(-1000, 3) \/\/ = -1000000","print(Bytes(x3.asData()))   \/\/ = [0, 0, 0, 0, 0, 0, 0, 3, 252, 24]","","let x4 = BigDecimal(-1000, -3) \/\/ = -1.000","print(Bytes(x4.asData()))   \/\/ = [255, 255, 255, 255, 255, 255, 255, 253, 252, 24]"],"type":"codeListing","syntax":"swift"},{"type":"codeListing","syntax":"swift","code":["let encoder = JSONEncoder()","let x1 = BigDecimal(1000, 3) \/\/ = 1000000","if let encoded = try? encoder.encode(x1) {","    \/\/ save `encoded` data somewhere or","","    \/\/ extract the JSON string from the data","    if let json = String(data: encoded, encoding: .utf8) {","        print(json)","    }","}"]},{"level":2,"text":"Decimal Formats","anchor":"Decimal-Formats","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Decimal values can be represented not only as BigDecimal’s but also as Double values,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Decimal (the Swift Foundation type) values, and Decimal32 \/ 64 \/ 128 values."},{"type":"text","text":" "},{"type":"text","text":"The strategy for working with other than BigDecimal values can be summarized as follows:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"convert the input values to BigDecimal’s using the appropriate initializer"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"compute the results","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"convert the results back to the desired output format using the appropriate conversion function","type":"text"}],"type":"paragraph"}]}]},{"inlineContent":[{"text":"As an example, suppose you must compute the average value of three values a, b and c which are encoded as Decimal32 values using Densely Packed Decimal (DPD) encoding.","type":"text"},{"type":"text","text":" "},{"text":"The result x must likewise be a Decimal32 value encoded using DPD.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ Input values","let a = UInt32(0x223e1117)  \/\/ = 7042.17 DPD encoded","let b = UInt32(0x22300901)  \/\/ =   22.01 DPD encoded","let c = UInt32(0xa230cc00)  \/\/ = -330.00 DPD encoded","\t","\/\/ Convert to BigDecimal's","let A = BigDecimal(a, .dpd)","let B = BigDecimal(b, .dpd)","let C = BigDecimal(c, .dpd)","\t","\/\/ Compute result","let X = (A + B + C).divide(3, Rounding.decimal32)","print(X)                    \/\/ = 2244.727","\t","\/\/ Convert result back to Decimal32","let x = X.asDecimal32(.dpd)","print(String(x, radix: 16)) \/\/ = 2a2513a7 (= 2244.727 DPD encoded)"]},{"anchor":"About-Infinities","type":"heading","level":2,"text":"About Infinities"},{"inlineContent":[{"type":"text","text":"The constants "},{"code":"BigDecimal.infinity","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"-BigDecimal.infinity","type":"codeVoice"},{"type":"text","text":" represent"},{"type":"text","text":" "},{"type":"text","text":"+Infinity and -Infinity respectively."},{"type":"text","text":" "},{"code":"-infinity","type":"codeVoice"},{"type":"text","text":" compares less than every finite number,"},{"type":"text","text":" "},{"text":"and every finite number compares less than ","type":"text"},{"type":"codeVoice","code":"infinity"},{"type":"text","text":". Arithmetic operations"},{"text":" ","type":"text"},{"type":"text","text":"involving infinite values is illustrated by the examples below:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let InfP = BigDecimal.infinity \/\/ Just to save some writing","let InfN = -BigDecimal.infinity","","print(InfP + 3)     \/\/ +Infinity","print(InfN + 3)     \/\/ -Infinity","print(InfP + InfP)  \/\/ +Infinity","print(InfP - InfP)  \/\/ NaN","print(InfP * 3)     \/\/ +Infinity","print(InfP * InfP)  \/\/ +Infinity","print(InfP * InfN)  \/\/ -Infinity","print(InfP * 0)     \/\/ NaN","print(InfP \/ 3)     \/\/ +Infinity","print(InfP \/ 0)     \/\/ +Infinity","print(1 \/ InfP)     \/\/ 0","print(1 \/ InfN)     \/\/ 0","print(InfP \/ InfP)  \/\/ NaN","print(InfP < InfP)  \/\/ false","print(InfP == InfP) \/\/ true","print(InfP != InfP) \/\/ false","print(InfP > InfP)  \/\/ false","print(Rounding.decimal32.round(InfP))    \/\/ +Infinity","print(InfP.scale(4))    \/\/ +Infinity","print(InfP.scale(-4))   \/\/ +Infinity","print(InfP.withExponent(10, .up))   \/\/ NaN"]},{"type":"heading","level":2,"anchor":"About-NaNs","text":"About NaN’s"},{"inlineContent":[{"text":"The IEEE 754 standard specifies two NaN’s, a quiet NaN (qNaN) and a signaling NaN (sNaN).","type":"text"},{"text":" ","type":"text"},{"text":"The constant ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"BigDecimal.NaN"}]},{"text":" corresponds to the quiet NaN and","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"BigDecimal.signalingNan"},{"type":"text","text":" to the signaling NaN."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Arithmetic operations where one or more input is NaN, return NaN as result."},{"text":" ","type":"text"},{"text":"Comparing NaN values is illustrated by the example below:","type":"text"}]},{"code":["let NaN = BigDecimal.NaN \/\/ Just to save some writing","\t","print(3 < NaN)      \/\/ false","print(NaN < 3)      \/\/ false","print(NaN < NaN)    \/\/ false","print(3 <= NaN)     \/\/ false","print(NaN <= 3)     \/\/ false","print(NaN <= NaN)   \/\/ false","print(3 > NaN)      \/\/ false","print(NaN > 3)      \/\/ false","print(NaN > NaN)    \/\/ false","print(3 >= NaN)     \/\/ false","print(NaN >= 3)     \/\/ false","print(NaN >= NaN)   \/\/ false","print(3 == NaN)     \/\/ false","print(NaN == 3)     \/\/ false","print(NaN == NaN)   \/\/ false","print(3 != NaN)     \/\/ true","print(NaN != 3)     \/\/ true","print(NaN != NaN)   \/\/ true !!!"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Because NaN != NaN is true, sorting a collection of BigDecimal’s doesn’t"},{"type":"text","text":" "},{"type":"text","text":"work if the collection contains one or more NaN’s. This is so, even if"},{"type":"text","text":" "},{"type":"text","text":"BigDecimal conforms to the Comparable protocol. Note: It is possible to"},{"type":"text","text":" "},{"text":"sort values including NaNs using the ","type":"text"},{"type":"codeVoice","code":"isTotallyOrdered(belowOrEqualTo:)"},{"type":"text","text":" "},{"type":"text","text":"method."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example uses "},{"type":"codeVoice","code":"isTotallyOrdered(belowOrEqualTo:)"},{"text":" to sort an","type":"text"},{"type":"text","text":" "},{"type":"text","text":"array of floating-point values, including some that are NaN:"}]},{"syntax":"swift","type":"codeListing","code":["var numbers = [2.5, 21.25, 3.0, .nan, -9.5]","numbers.sort { !$1.isTotallyOrdered(belowOrEqualTo: $0) }","print(numbers)","\/\/ Prints \"[-9.5, 2.5, 3.0, 21.25, nan]\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is a static boolean variable "},{"inlineContent":[{"type":"text","text":"BigDecimal.NaNFlag"}],"type":"emphasis"},{"text":" which is set to","type":"text"},{"text":" ","type":"text"},{"inlineContent":[{"text":"true","type":"text"}],"type":"emphasis"},{"text":" whenever a NaN value is generated. It can be set to ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"false","type":"text"}]},{"text":" by","type":"text"},{"text":" ","type":"text"},{"text":"application code. Therefore, to check if a sequence of code generates NaN,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"set NaNFlag to "},{"type":"emphasis","inlineContent":[{"type":"text","text":"false"}]},{"text":" before the code and check it after the code. Since","type":"text"},{"text":" ","type":"text"},{"text":"a BigDecimal has a stored property ","type":"text"},{"inlineContent":[{"type":"text","text":"isNaN"}],"type":"emphasis"},{"type":"text","text":", it is of course also possible to"},{"text":" ","type":"text"},{"type":"text","text":"check for a NaN value at any time."}]},{"type":"heading","level":2,"text":"References","anchor":"References"},{"type":"paragraph","inlineContent":[{"text":"Algorithms from the following books and papers have been used in the implementation.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"There are references in the source code where appropriate."}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"[GRANLUND] - Moller and Granlund: Improved Division by Invariant Integers, 2011"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"[IEEE] - IEEE Standard for Floating-Point Arithmetic, 2019"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"[KNUTH] - Donald E. Knuth: Seminumerical Algorithms, Addison-Wesley 1971"}]}]}]},{"type":"heading","anchor":"Acknowledgement","level":2,"text":"Acknowledgement"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"text":"Much of the original ","type":"text"},{"identifier":"https:\/\/github.com\/leif-ibsen\/BigDecimal.git","isActive":true,"type":"reference"},{"type":"text","text":" (pre-V2) was created by Leif Ibsen."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Some unit test cases come from the "},{"type":"reference","identifier":"http:\/\/speleotrove.com\/decimal","isActive":true}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Additional unit test cases and some algorithms are from the","type":"text"},{"type":"text","text":" "},{"identifier":"https:\/\/www.intel.com\/content\/www\/us\/en\/developer\/articles\/tool\/intel-decimal-floating-point-math-library.html","isActive":true,"type":"reference"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Floating point math functions are translated to Swift from the","type":"text"},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/github.com\/eobermuhlner\/big-math","isActive":true},{"type":"text","text":" implementation by Eric Obermühlner."}]}]}]}]}],"identifier":{"url":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal","interfaceLanguage":"swift"},"references":{"doc://bigdecimal.BigDecimal/documentation/BigDecimal/CBDecimal":{"navigatorTitle":[{"kind":"identifier","text":"CBDecimal"}],"kind":"symbol","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/CBDecimal","abstract":[],"url":"\/documentation\/bigdecimal\/cbdecimal","title":"CBDecimal","role":"symbol","fragments":[{"text":"typealias","kind":"keyword"},{"kind":"text","text":" "},{"text":"CBDecimal","kind":"identifier"}],"type":"topic"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/BigDecimal":{"role":"symbol","kind":"symbol","navigatorTitle":[{"text":"BigDecimal","kind":"identifier"}],"title":"BigDecimal","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"BigDecimal","kind":"identifier"}],"abstract":[{"type":"text","text":"A signed decimal value of unbounded precision (actually there is a"},{"type":"text","text":" "},{"text":"practical limit defined by ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/maxDigits"},{"type":"text","text":" of 200 that the user can change)."},{"type":"text","text":" "},{"text":"A ","type":"text"},{"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal","isActive":true},{"type":"text","text":" value is represented as a signed "},{"code":"BInt","type":"codeVoice"},{"text":" significand","type":"text"},{"type":"text","text":" "},{"text":"and a signed ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" exponent that is limited to ten digits.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The value of a Self is "},{"isActive":true,"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/digits"},{"type":"text","text":" * 10^"},{"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/exponent","isActive":true},{"text":".","type":"text"}],"type":"topic","url":"\/documentation\/bigdecimal\/bigdecimal"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/PowerNIterator":{"navigatorTitle":[{"text":"PowerNIterator","kind":"identifier"}],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerNIterator","abstract":[],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"PowerNIterator","kind":"identifier"}],"kind":"symbol","url":"\/documentation\/bigdecimal\/powerniterator","type":"topic","title":"PowerNIterator"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/CoshCalculator":{"url":"\/documentation\/bigdecimal\/coshcalculator","type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"CoshCalculator"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/CoshCalculator","title":"CoshCalculator","abstract":[{"type":"text","text":"Calculates hyperbolic cosine using the Maclaurin\/Taylor series."}],"navigatorTitle":[{"kind":"identifier","text":"CoshCalculator"}]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/DecimalFloatingPoint":{"url":"\/documentation\/bigdecimal\/decimalfloatingpoint","title":"DecimalFloatingPoint","navigatorTitle":[{"kind":"identifier","text":"DecimalFloatingPoint"}],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/DecimalFloatingPoint","kind":"symbol","type":"topic","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"DecimalFloatingPoint","kind":"identifier"}],"abstract":[{"text":"A radix-10 (decimal) floating-point type.","type":"text"}]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/PowerTwoNIterator":{"type":"topic","title":"PowerTwoNIterator","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerTwoNIterator","url":"\/documentation\/bigdecimal\/powertwoniterator","abstract":[{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerIterator","type":"reference","isActive":true},{"text":" to calculate the 2*n term.","type":"text"}],"role":"symbol","navigatorTitle":[{"text":"PowerTwoNIterator","kind":"identifier"}],"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"PowerTwoNIterator"}],"kind":"symbol"},"https://github.com/eobermuhlner/big-math":{"type":"link","titleInlineContent":[{"type":"text","text":"Java BigDecimalMath"}],"url":"https:\/\/github.com\/eobermuhlner\/big-math","identifier":"https:\/\/github.com\/eobermuhlner\/big-math","title":"Java BigDecimalMath"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Decimal32":{"navigatorTitle":[{"text":"Decimal32","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal32","title":"Decimal32","kind":"symbol","url":"\/documentation\/bigdecimal\/decimal32","abstract":[{"text":"Implementation of the 32-bit Decimal32 floating-point operations from","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"IEEE STD 754-2019 for Floating-Point Arithmetic."}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Decimal32"}],"role":"symbol"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/PowerIterator":{"navigatorTitle":[{"text":"PowerIterator","kind":"identifier"}],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerIterator","url":"\/documentation\/bigdecimal\/poweriterator","role":"symbol","title":"PowerIterator","abstract":[],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"PowerIterator","kind":"identifier"}],"kind":"symbol","type":"topic"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/BigDecimal/maxDigits":{"kind":"symbol","type":"topic","url":"\/documentation\/bigdecimal\/bigdecimal\/maxdigits","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"let"},{"text":" ","kind":"text"},{"text":"maxDigits","kind":"identifier"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"}],"role":"symbol","abstract":[],"title":"maxDigits","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/maxDigits"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Decimal64":{"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Decimal64"}],"abstract":[{"type":"text","text":"Implementation of the 64-bit Decimal64 floating-point operations from"},{"type":"text","text":" "},{"text":"IEEE STD 754-2019 for Floating-Point Arithmetic.","type":"text"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"Decimal64"}],"type":"topic","url":"\/documentation\/bigdecimal\/decimal64","title":"Decimal64","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal64"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Sign":{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Sign","role":"symbol","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"text":"Sign","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"Sign"}],"abstract":[],"url":"\/documentation\/bigdecimal\/sign","kind":"symbol","title":"Sign","type":"topic"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/BigDecimal/digits":{"kind":"symbol","type":"topic","url":"\/documentation\/bigdecimal\/bigdecimal\/digits","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"digits","kind":"identifier"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"BInt","preciseIdentifier":"s:6BigInt4BIntV"}],"role":"symbol","abstract":[{"type":"text","text":"The signed BInt significand"}],"title":"digits","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/digits"},"https://www.intel.com/content/www/us/en/developer/articles/tool/intel-decimal-floating-point-math-library.html":{"type":"link","titleInlineContent":[{"text":"Intel C Decimal Floating-Point Math library","type":"text"}],"url":"https:\/\/www.intel.com\/content\/www\/us\/en\/developer\/articles\/tool\/intel-decimal-floating-point-math-library.html","identifier":"https:\/\/www.intel.com\/content\/www\/us\/en\/developer\/articles\/tool\/intel-decimal-floating-point-math-library.html","title":"Intel C Decimal Floating-Point Math library"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/RawDecimal":{"kind":"symbol","type":"topic","url":"\/documentation\/bigdecimal\/rawdecimal","title":"RawDecimal","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"RawDecimal"}],"navigatorTitle":[{"text":"RawDecimal","kind":"identifier"}],"abstract":[],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/RawDecimal"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/AsinCalculator":{"url":"\/documentation\/bigdecimal\/asincalculator","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/AsinCalculator","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsinCalculator"}],"navigatorTitle":[{"text":"AsinCalculator","kind":"identifier"}],"kind":"symbol","title":"AsinCalculator","role":"symbol","type":"topic","abstract":[{"type":"text","text":"Calculates arcsine using the Maclaurin\/Taylor series."}]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Decimal":{"abstract":[{"text":"Implementation of a clone of Apple’s Decimal floating-point data type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal"},{"type":"text","text":" operations."}],"role":"symbol","kind":"symbol","type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal","url":"\/documentation\/bigdecimal\/decimal","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Decimal","kind":"identifier"}],"title":"Decimal","navigatorTitle":[{"text":"Decimal","kind":"identifier"}]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/BigDecimal/exponent":{"url":"\/documentation\/bigdecimal\/bigdecimal\/exponent","kind":"symbol","role":"symbol","abstract":[{"type":"text","text":"The signed exponent - the value of "},{"type":"emphasis","inlineContent":[{"type":"text","text":"self"}]},{"type":"text","text":" is "},{"inlineContent":[{"text":"self.significand","type":"text"}],"type":"emphasis"},{"type":"text","text":" *"},{"type":"text","text":" "},{"type":"text","text":"10^"},{"inlineContent":[{"type":"text","text":"self.exponent"}],"type":"emphasis"}],"fragments":[{"text":"var","kind":"keyword"},{"kind":"text","text":" "},{"text":"exponent","kind":"identifier"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:Si","text":"Int"}],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/exponent","title":"exponent","type":"topic"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Decimal128":{"type":"topic","title":"Decimal128","role":"symbol","navigatorTitle":[{"text":"Decimal128","kind":"identifier"}],"kind":"symbol","abstract":[{"type":"text","text":"Implementation of the 128-bit Decimal128 floating-point operations from"},{"text":" ","type":"text"},{"type":"text","text":"IEEE STD 754-2019 for Floating-Point Arithmetic."}],"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"Decimal128","kind":"identifier"}],"url":"\/documentation\/bigdecimal\/decimal128","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal128"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/SinCalculator":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"SinCalculator","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"SinCalculator"}],"role":"symbol","title":"SinCalculator","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/SinCalculator","url":"\/documentation\/bigdecimal\/sincalculator","type":"topic","kind":"symbol","abstract":[{"type":"text","text":"Calculates sine using the Maclaurin\/Taylor series."}]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/SinhCalculator":{"abstract":[{"type":"text","text":"Calculates hyperbolic sine using the Maclaurin\/Taylor series."}],"url":"\/documentation\/bigdecimal\/sinhcalculator","type":"topic","title":"SinhCalculator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"SinhCalculator"}],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/SinhCalculator","role":"symbol","navigatorTitle":[{"text":"SinhCalculator","kind":"identifier"}],"kind":"symbol"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/RoundingRule":{"url":"\/documentation\/bigdecimal\/roundingrule","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/RoundingRule","type":"topic","kind":"symbol","title":"RoundingRule","navigatorTitle":[{"text":"RoundingRule","kind":"identifier"}],"fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"RoundingRule"}],"role":"symbol","abstract":[{"type":"text","text":"The rounding modes"}]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/ExpCalculator":{"abstract":[{"text":"Calculates exp using the Maclaurin\/Taylor series.","type":"text"}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"ExpCalculator","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/ExpCalculator","navigatorTitle":[{"kind":"identifier","text":"ExpCalculator"}],"title":"ExpCalculator","url":"\/documentation\/bigdecimal\/expcalculator","kind":"symbol"},"http://speleotrove.com/decimal":{"type":"link","titleInlineContent":[{"type":"text","text":"General Decimal Arithmetic"}],"url":"http:\/\/speleotrove.com\/decimal","identifier":"http:\/\/speleotrove.com\/decimal","title":"General Decimal Arithmetic"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/SeriesCalculator":{"fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"SeriesCalculator"}],"navigatorTitle":[{"text":"SeriesCalculator","kind":"identifier"}],"kind":"symbol","role":"symbol","url":"\/documentation\/bigdecimal\/seriescalculator","type":"topic","abstract":[],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/SeriesCalculator","title":"SeriesCalculator"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal":{"url":"\/documentation\/bigdecimal","type":"topic","abstract":[{"text":"The BigDecimal package provides arbitrary-precision (with an adjustable upper","type":"text"},{"type":"text","text":" "},{"type":"text","text":"limit for performance) and fixed-precision decimal arithmetic in Swift."}],"title":"BigDecimal","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal","kind":"symbol","role":"collection"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/PowerTwoNPlusOneIterator":{"type":"topic","navigatorTitle":[{"kind":"identifier","text":"PowerTwoNPlusOneIterator"}],"abstract":[{"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerIterator","isActive":true},{"text":" to calculate the 2*n+1 term.","type":"text"}],"kind":"symbol","url":"\/documentation\/bigdecimal\/powertwonplusoneiterator","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"PowerTwoNPlusOneIterator"}],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerTwoNPlusOneIterator","role":"symbol","title":"PowerTwoNPlusOneIterator"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/IntRange":{"kind":"symbol","url":"\/documentation\/bigdecimal\/intrange","abstract":[],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/IntRange","title":"IntRange","role":"symbol","type":"topic","fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"text":"IntRange","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"IntRange"}]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Status":{"navigatorTitle":[{"kind":"identifier","text":"Status"}],"type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Status","title":"Status","kind":"symbol","url":"\/documentation\/bigdecimal\/status","abstract":[],"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Status","kind":"identifier"}],"role":"symbol"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Rounding":{"type":"topic","title":"Rounding","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Rounding","url":"\/documentation\/bigdecimal\/rounding","navigatorTitle":[{"kind":"identifier","text":"Rounding"}],"role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"Rounding","kind":"identifier"}],"kind":"symbol","abstract":[{"text":"BigDecimal rounding object containing a rounding mode and a precision","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which is the number of digits in the rounded result"}]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/ComplexModule":{"url":"\/documentation\/bigdecimal\/complexmodule","type":"topic","kind":"symbol","title":"ComplexModule","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/ComplexModule","abstract":[],"role":"collection"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Swift":{"role":"collection","url":"\/documentation\/bigdecimal\/swift","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Swift","abstract":[],"title":"Swift","type":"topic","kind":"symbol"},"https://github.com/leif-ibsen/BigDecimal.git":{"type":"link","titleInlineContent":[{"text":"BigDecimal","type":"text"}],"url":"https:\/\/github.com\/leif-ibsen\/BigDecimal.git","identifier":"https:\/\/github.com\/leif-ibsen\/BigDecimal.git","title":"BigDecimal"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/BigDecimal/infinity":{"title":"infinity","role":"symbol","abstract":[{"type":"text","text":"BigDecimal(‘Infinity’)"}],"type":"topic","kind":"symbol","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/infinity","url":"\/documentation\/bigdecimal\/bigdecimal\/infinity","fragments":[{"kind":"keyword","text":"static"},{"text":" ","kind":"text"},{"text":"let","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"infinity"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:10BigDecimalAAV","text":"BigDecimal"}]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/CosCalculator":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"CosCalculator","kind":"identifier"}],"kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CosCalculator"}],"abstract":[{"type":"text","text":"Calculates cosine using the Maclaurin\/Taylor series."}],"role":"symbol","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/CosCalculator","title":"CosCalculator","url":"\/documentation\/bigdecimal\/coscalculator"}}}