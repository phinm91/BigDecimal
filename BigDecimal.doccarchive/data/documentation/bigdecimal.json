{"kind":"symbol","abstract":[{"type":"text","text":"The BigDecimal package provides arbitrary-precision (with an adjustable upper"},{"type":"text","text":" "},{"type":"text","text":"limit for performance) and fixed-precision decimal arithmetic in Swift."}],"schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"roleHeading":"Framework","modules":[{"name":"BigDecimal"}],"externalID":"BigDecimal","title":"BigDecimal","role":"collection","symbolKind":"module"},"identifier":{"url":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal","interfaceLanguage":"swift"},"topicSections":[{"title":"Protocols","generated":true,"identifiers":["doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/DecimalFloatingPoint","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerIterator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/SeriesCalculator"],"anchor":"Protocols"},{"generated":true,"title":"Structures","identifiers":["doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/AsinCalculator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/CosCalculator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/CoshCalculator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal128","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal32","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal64","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/ExpCalculator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerNIterator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerTwoNIterator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerTwoNPlusOneIterator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/RawDecimal","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Rounding","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/SinCalculator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/SinhCalculator","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Status"],"anchor":"Structures"},{"title":"Functions","identifiers":["doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/print(_:separator:terminator:)"],"anchor":"Functions","generated":true},{"title":"Type Aliases","generated":true,"identifiers":["doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/CBDecimal","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/IntRange","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/RoundingRule","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Sign"],"anchor":"Type-Aliases"},{"title":"Extended Modules","identifiers":["doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/ComplexModule","doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Swift"],"generated":true,"anchor":"Extended-Modules"}],"variants":[{"paths":["\/documentation\/bigdecimal"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[],"hierarchy":{"paths":[[]]},"primaryContentSections":[{"kind":"content","content":[{"level":2,"type":"heading","text":"Overview","anchor":"overview"},{"inlineContent":[{"type":"text","text":"Its functionality falls in the following categories:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Arithmetic: addition, subtraction, multiplication, division, remainder and"},{"text":" ","type":"text"},{"text":"exponentiation","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Compliant with "},{"code":"DecimalFloatingPoint","type":"codeVoice"},{"text":" and, optionally, ","type":"text"},{"type":"codeVoice","code":"Real"},{"type":"text","text":" protocols."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Support for complex decimal numbers via "},{"code":"swift-numerics","type":"codeVoice"},{"type":"text","text":" if "},{"type":"codeVoice","code":"Real"},{"type":"text","text":" protocol"},{"text":" ","type":"text"},{"type":"text","text":"compliance is enabled."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Constants: ","type":"text"},{"type":"codeVoice","code":"pi"},{"text":", ","type":"text"},{"type":"codeVoice","code":"zero"},{"type":"text","text":", "},{"type":"codeVoice","code":"one"},{"type":"text","text":", "},{"type":"codeVoice","code":"ten"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Functions: exp, log, log10, log2, pow, sqrt, root, factorial, gamma,"},{"type":"text","text":" "},{"type":"text","text":"trig + inverse, hyperbolic + inverse"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Rounding and scaling according to one of the rounding modes:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"awayFromZero"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"down","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"towardZero"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"toNearestOrEven","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"toNearestOrAwayFromZero","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"up","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"Comparison: the six standard operators ","type":"text"},{"code":"==","type":"codeVoice"},{"type":"text","text":", "},{"code":"!=","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"<"},{"type":"text","text":", "},{"type":"codeVoice","code":"<="},{"text":", ","type":"text"},{"code":">","type":"codeVoice"},{"text":", and ","type":"text"},{"code":">=","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Conversion: to String, to Double, to Decimal (the Swift Foundation type), to"},{"type":"text","text":" "},{"type":"text","text":"Decimal32 \/ Decimal64 \/ Decimal128"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Support for Decimal32, Decimal64 and Decimal128 values stored as UInt32,"},{"type":"text","text":" "},{"text":"UInt64 and UInt128 values respectively, using Densely Packed Decimal (DPD)","type":"text"},{"type":"text","text":" "},{"type":"text","text":"encoding or Binary Integer Decimal (BID) encoding"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Support for Decimal32, Decimal64 and Decimal128 mathematical operations","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Supports the IEEE 754 concepts of Infinity and NaN (Not a Number) with the"},{"type":"text","text":" "},{"type":"text","text":"latter having a "},{"code":"signaling","type":"codeVoice"},{"type":"text","text":" option."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"heading","anchor":"Dependencies","level":2,"text":"Dependencies"},{"type":"paragraph","inlineContent":[{"text":"BigDecimal requires Swift from macOS 13.3+, iOS 16.4+, macCatalyst 16.4+,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"tvOS 16.4+, or watchOS 9.4+. It also requires that the "},{"type":"codeVoice","code":"Int"},{"text":" type be a 64-bit","type":"text"},{"type":"text","text":" "},{"text":"type.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The BigDecimal package depends on the BigInt and UInt128 packages."}]},{"code":["dependencies: [","  .package(url: \"https:\/\/github.com\/mgriebling\/BigInt.git\", from: \"2.0.0\"),","  .package(url: \"https:\/\/github.com\/mgriebling\/UInt128.git\", from: \"3.0.0\")","]"],"type":"codeListing","syntax":null},{"anchor":"Usage","level":2,"text":"Usage","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In your project’s Package.swift file add a dependency like"}]},{"type":"codeListing","syntax":null,"code":["dependencies: [","  .package(url: \"https:\/\/github.com\/mgriebling\/BigDecimal.git\", from: \"2.0.0\"),","]"]},{"anchor":"Basics","level":2,"type":"heading","text":"Basics"},{"type":"heading","level":3,"anchor":"Creating-BigDecimals","text":"Creating BigDecimal’s"},{"code":["\/\/ From an integer","let x1 = BigDecimal(270) \/\/ = 270","let x2 = BigDecimal(270, -2)  \/\/ = 2.70","let x3 = BigDecimal(314159265, -8) \/\/ = 3.14159265","  ","\/\/ From a BInt","let x4 = BigDecimal(BInt(314159265), -8) \/\/ = 3.14159265","let x5 = BigDecimal(BInt(100), -3) \/\/ = 0.100","  ","\/\/ From a string literal","let rnd1 = Rounding(.halfEven, 2)","let x6 = BigDecimal(\"0.123\").round(rnd1) \/\/ = 0.12","let x7 = BigDecimal(\"3.14159265\") \/\/ = 3.14159265","  ","\/\/ From a double","let rnd2 = Rounding(.halfEven, 9)","let x8 = BigDecimal(0.1).round(rnd2)  \/\/ = 0.100000000","let x9 = BigDecimal(0.1) \/\/ = 0.1000000000000000055511151231257827021181583404541015625","let x10 = BigDecimal(3.14159265) \/\/ = 3.141592650000000208621031561051495373249053955078125","let x11 = BigDecimal(3.14159265).round(rnd2) \/\/ = 3.14159265","","\/\/ From Decimal32 \/ 64 \/ 128 encoded values","let x32 = BigDecimal(UInt32(0x223000f0), .dpd) \/\/ = 1.70","let x64 = BigDecimal(UInt64(0x22300000000000f0), .dpd) \/\/ = 1.70","let x128 = BigDecimal(UInt128(0x2207800000000000, 0x00000000000000f0), .dpd) \/\/ = 1.70"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Because Double values cannot represent all decimal values exactly,","type":"text"},{"text":" ","type":"text"},{"text":"one sees that BigDecimal(0.1) is not exactly equal to 1 \/ 10 as one might expect.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"On the other hand, BigDecimal(“0.1”) is in fact exactly equal to 1 \/ 10."}],"type":"paragraph"},{"level":3,"text":"Converting BigDecimal’s","type":"heading","anchor":"Converting-BigDecimals"},{"type":"paragraph","inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal"},{"type":"text","text":" values can be converted to "},{"code":"String","type":"codeVoice"},{"text":" values, ","type":"text"},{"type":"codeVoice","code":"Double"},{"type":"text","text":" values,"},{"text":" ","type":"text"},{"code":"Decimal","type":"codeVoice"},{"type":"text","text":" (the Swift Foundation type) values, and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal32"},{"text":", ","type":"text"},{"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal64","isActive":true},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and "},{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal128","isActive":true,"type":"reference"},{"text":" values.","type":"text"}]},{"text":"To String","type":"heading","level":4,"anchor":"To-String"},{"type":"codeListing","syntax":"swift","code":["let x1 = BigDecimal(\"2.1\").pow(3)","print(x1.asString()) \/\/ = 9.261"]},{"type":"heading","level":4,"anchor":"To-Double","text":"To Double"},{"syntax":"swift","code":["let x2 = BigDecimal(\"2.1\").pow(3)","print(x2.asDouble()) \/\/ = 9.261"],"type":"codeListing"},{"level":4,"text":"To Decimal (the Swift Foundation type)","anchor":"To-Decimal-the-Swift-Foundation-type","type":"heading"},{"syntax":"swift","type":"codeListing","code":["let x3 = BigDecimal(\"1.70\")","let xd: Decimal = x3.asDecimal()","print(xd) \/\/ = 1.70"]},{"type":"heading","anchor":"To-Decimal32--64--128","text":"To Decimal32 \/ 64 \/ 128","level":4},{"type":"codeListing","code":["let x4 = BigDecimal(\"1.70\")","let x32: UInt32 = x4.asDecimal32(.dpd)","let x64: UInt64 = x4.asDecimal64(.dpd)","let x128: UInt128 = x4.asDecimal128(.dpd)","print(String(x32, radix: 16))  \/\/ = 223000f0","print(String(x64, radix: 16))  \/\/ = 22300000000000f0","print(String(x128, radix: 16)) \/\/ = 220780000000000000000000000000f0"],"syntax":"swift"},{"anchor":"Comparing-BigDecimals","type":"heading","level":3,"text":"Comparing BigDecimal’s"},{"inlineContent":[{"type":"text","text":"The six standard operators == != < <= > >= are available to compare values."},{"text":" ","type":"text"},{"text":"The two operands may either be two ","type":"text"},{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal","isActive":true,"type":"reference"},{"text":"’s or a ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal"},{"type":"text","text":" and"},{"type":"text","text":" "},{"type":"text","text":"an integer. If neither of the operands is NaN, the operators perform as expected."},{"type":"text","text":" "},{"text":"For example, -","type":"text"},{"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/infinity","isActive":true},{"type":"text","text":" is less than any finite number which in"},{"text":" ","type":"text"},{"text":"turn is less than +","type":"text"},{"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/infinity","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Please see the section "},{"inlineContent":[{"type":"text","text":"About NaN’s"}],"type":"emphasis"},{"type":"text","text":" for the rules governing comparison involving NaN’s."}]},{"inlineContent":[{"text":"The static function ","type":"text"},{"code":"BigDecimal.maximum(x:y:)","type":"codeVoice"},{"text":" returns the non-NaN number if","type":"text"},{"type":"text","text":" "},{"text":"either x or y is NaN; otherwise it returns the larger of x and y.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The static function ","type":"text"},{"code":"BigDecimal.minimum(x:y:)","type":"codeVoice"},{"text":" returns the non-NaN number if","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"either x or y is NaN; otherwise it returns the smaller of x and y."}]},{"text":"Exact Arithmetic","type":"heading","anchor":"Exact-Arithmetic","level":3},{"type":"paragraph","inlineContent":[{"text":"The ‘+’, ‘-’, and ‘*’ operators always produce exact results. The ‘\/’ operator","type":"text"},{"type":"text","text":" "},{"text":"truncates the exact result to an integer.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let a = BigDecimal(\"25.1\")","let b = BigDecimal(\"12.0041\")","","print(a + b) \/\/ = 37.1041","print(a - b) \/\/ = 13.0959","print(a * b) \/\/ = 301.30291","print(a \/ b) \/\/ = 2"]},{"inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"text":"quotientAndRemainder","type":"text"}]},{"text":" function produces an integer quotient and exact remainder","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["print(a.quotientAndRemainder(b)) \/\/ = (quotient: 2, remainder: 1.0918)"],"type":"codeListing"},{"level":3,"anchor":"Rounded-Arithmetic","type":"heading","text":"Rounded Arithmetic"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Rounding is controlled by Rounding objects that contain a rounding mode and a"},{"type":"text","text":" "},{"type":"text","text":"precision, which is the number of digits in the rounded result."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The rounding modes are:"}]},{"items":[{"content":[{"inlineContent":[{"text":"awayFromZero - round away from 0","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"down - round towards -infinity","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"up - round towards +infinity"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"towardZero - round towards 0"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"toNearestOrEven - round to nearest, ties to even","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"toNearestOrAwayFromZero - round to nearest, ties away from 0"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"add"}]},{"type":"text","text":", "},{"inlineContent":[{"text":"subtract","type":"text"}],"type":"emphasis"},{"text":" and ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"multiply"}]},{"text":" methods have a Rounding parameter that","type":"text"},{"type":"text","text":" "},{"text":"controls how the result is rounded.","type":"text"}],"type":"paragraph"},{"text":"Examples","anchor":"Examples","type":"heading","level":4},{"code":["let a = BigDecimal(\"25.1E-2\")","let b = BigDecimal(\"12.0041E-3\")","let rnd = Rounding(.ceiling, 3)","\t","print(a + b) \/\/ = 0.2630041","print(a.add(b, rnd)) \/\/ = 0.264","print(a - b) \/\/ = 0.2389959","print(a.subtract(b, rnd)) \/\/ = 0.239","print(a * b) \/\/ = 0.0030130291","print(a.multiply(b, rnd)) \/\/ = 0.00302"],"type":"codeListing","syntax":"swift"},{"text":"Precise division","level":3,"anchor":"Precise-division","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"inlineContent":[{"type":"text","text":"divide"}],"type":"emphasis"},{"text":" method, that has an optional rounding parameter, performs division.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"If the quotient has finite decimal expansion, the rounding parameter may or may not be present, it is used if it is there."},{"type":"text","text":" "},{"type":"text","text":"If the quotient has infinite decimal expansion, the rounding parameter must be present and is used to round the result."}]},{"level":4,"text":"Examples","type":"heading","anchor":"Examples"},{"code":["let x1 = BigDecimal(3)","let x2 = BigDecimal(48)","print(x1.divide(x2))  \/\/ = 0.0625","let rnd = Rounding(.ceiling, 2)","print(x1.divide(x2, rnd))  \/\/ = 0.063","\t","let x3 = BigDecimal(3)","let x4 = BigDecimal(49)","print(x3.divide(x4))       \/\/ = NaN because the quotient has infinite decimal expansion 0.06122448...","print(x3.divide(x4, rnd))  \/\/ = 0.062"],"syntax":"swift","type":"codeListing"},{"level":2,"text":"Data Encoding","type":"heading","anchor":"Data-Encoding"},{"type":"paragraph","inlineContent":[{"type":"text","text":"BigDecimal’s can be encoded as Data objects (perhaps for long term storage) using the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"asData"}]},{"type":"text","text":" method,"},{"text":" ","type":"text"},{"text":"and they can be regenerated from their Data encoding using the appropriate initializer.","type":"text"},{"text":" ","type":"text"},{"text":"The encoding rules are:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"The encoding contains nine or more bytes. The first eight bytes is a"},{"text":" ","type":"text"},{"type":"text","text":"Big Endian encoding of the signed exponent."},{"type":"text","text":" "},{"type":"text","text":"The remaining bytes is a Big Endian encoding of the signed significand."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"NaN’s (and signaling NaNs) are encoded as a single byte = 0"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"positive infinity is encoded as a single byte = 1"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"negative infinity is encoded as a single byte = 2"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"negative zero is encoded as a single byte = 3"}]}]}]},{"inlineContent":[{"text":"It is also possible to encode BigDecimal’s using the ","type":"text"},{"type":"codeVoice","code":"JSONEncoder"},{"text":" or as a","type":"text"},{"type":"text","text":" "},{"text":"property list using the ","type":"text"},{"type":"codeVoice","code":"PropertyListEncoder"},{"text":" as in the second example.","type":"text"}],"type":"paragraph"},{"text":"Examples","type":"heading","level":3,"anchor":"Examples"},{"type":"codeListing","code":["let x1 = BigDecimal(1000, 3) \/\/ = 1000000","print(Bytes(x1.asData()))   \/\/ = [0, 0, 0, 0, 0, 0, 0, 3, 3, 232]","","let x2 = BigDecimal(1000, -3) \/\/ = 1.000","print(Bytes(x2.asData()))   \/\/ = [255, 255, 255, 255, 255, 255, 255, 253, 3, 232]","","let x3 = BigDecimal(-1000, 3) \/\/ = -1000000","print(Bytes(x3.asData()))   \/\/ = [0, 0, 0, 0, 0, 0, 0, 3, 252, 24]","","let x4 = BigDecimal(-1000, -3) \/\/ = -1.000","print(Bytes(x4.asData()))   \/\/ = [255, 255, 255, 255, 255, 255, 255, 253, 252, 24]"],"syntax":"swift"},{"type":"codeListing","syntax":"swift","code":["let encoder = JSONEncoder()","let x1 = BigDecimal(1000, 3) \/\/ = 1000000","if let encoded = try? encoder.encode(x1) {","    \/\/ save `encoded` data somewhere or","","    \/\/ extract the JSON string from the data","    if let json = String(data: encoded, encoding: .utf8) {","        print(json)","    }","}"]},{"text":"Decimal Formats","level":2,"type":"heading","anchor":"Decimal-Formats"},{"inlineContent":[{"text":"Decimal values can be represented not only as BigDecimal’s but also as Double values,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Decimal (the Swift Foundation type) values, and Decimal32 \/ 64 \/ 128 values."},{"type":"text","text":" "},{"type":"text","text":"The strategy for working with other than BigDecimal values can be summarized as follows:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"convert the input values to BigDecimal’s using the appropriate initializer","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"compute the results"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"convert the results back to the desired output format using the appropriate conversion function"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"As an example, suppose you must compute the average value of three values a, b and c which are encoded as Decimal32 values using Densely Packed Decimal (DPD) encoding.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The result x must likewise be a Decimal32 value encoded using DPD."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Input values","let a = UInt32(0x223e1117)  \/\/ = 7042.17 DPD encoded","let b = UInt32(0x22300901)  \/\/ =   22.01 DPD encoded","let c = UInt32(0xa230cc00)  \/\/ = -330.00 DPD encoded","\t","\/\/ Convert to BigDecimal's","let A = BigDecimal(a, .dpd)","let B = BigDecimal(b, .dpd)","let C = BigDecimal(c, .dpd)","\t","\/\/ Compute result","let X = (A + B + C).divide(3, Rounding.decimal32)","print(X)                    \/\/ = 2244.727","\t","\/\/ Convert result back to Decimal32","let x = X.asDecimal32(.dpd)","print(String(x, radix: 16)) \/\/ = 2a2513a7 (= 2244.727 DPD encoded)"]},{"anchor":"About-Infinities","type":"heading","level":2,"text":"About Infinities"},{"type":"paragraph","inlineContent":[{"text":"The constants ","type":"text"},{"code":"BigDecimal.infinity","type":"codeVoice"},{"type":"text","text":" and "},{"code":"-BigDecimal.infinity","type":"codeVoice"},{"type":"text","text":" represent"},{"type":"text","text":" "},{"type":"text","text":"+Infinity and -Infinity respectively."},{"text":" ","type":"text"},{"type":"codeVoice","code":"-infinity"},{"type":"text","text":" compares less than every finite number,"},{"type":"text","text":" "},{"type":"text","text":"and every finite number compares less than "},{"code":"infinity","type":"codeVoice"},{"type":"text","text":". Arithmetic operations"},{"type":"text","text":" "},{"type":"text","text":"involving infinite values is illustrated by the examples below:"}]},{"type":"codeListing","code":["let InfP = BigDecimal.infinity \/\/ Just to save some writing","let InfN = -BigDecimal.infinity","","print(InfP + 3)     \/\/ +Infinity","print(InfN + 3)     \/\/ -Infinity","print(InfP + InfP)  \/\/ +Infinity","print(InfP - InfP)  \/\/ NaN","print(InfP * 3)     \/\/ +Infinity","print(InfP * InfP)  \/\/ +Infinity","print(InfP * InfN)  \/\/ -Infinity","print(InfP * 0)     \/\/ NaN","print(InfP \/ 3)     \/\/ +Infinity","print(InfP \/ 0)     \/\/ +Infinity","print(1 \/ InfP)     \/\/ 0","print(1 \/ InfN)     \/\/ 0","print(InfP \/ InfP)  \/\/ NaN","print(InfP < InfP)  \/\/ false","print(InfP == InfP) \/\/ true","print(InfP != InfP) \/\/ false","print(InfP > InfP)  \/\/ false","print(Rounding.decimal32.round(InfP))    \/\/ +Infinity","print(InfP.scale(4))    \/\/ +Infinity","print(InfP.scale(-4))   \/\/ +Infinity","print(InfP.withExponent(10, .up))   \/\/ NaN"],"syntax":"swift"},{"type":"heading","text":"About NaN’s","anchor":"About-NaNs","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The IEEE 754 standard specifies two NaN’s, a quiet NaN (qNaN) and a signaling NaN (sNaN)."},{"type":"text","text":" "},{"type":"text","text":"The constant "},{"type":"emphasis","inlineContent":[{"type":"text","text":"BigDecimal.NaN"}]},{"type":"text","text":" corresponds to the quiet NaN and"},{"text":" ","type":"text"},{"type":"codeVoice","code":"BigDecimal.signalingNan"},{"type":"text","text":" to the signaling NaN."}]},{"type":"paragraph","inlineContent":[{"text":"Arithmetic operations where one or more input is NaN, return NaN as result.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Comparing NaN values is illustrated by the example below:"}]},{"syntax":"swift","code":["let NaN = BigDecimal.NaN \/\/ Just to save some writing","\t","print(3 < NaN)      \/\/ false","print(NaN < 3)      \/\/ false","print(NaN < NaN)    \/\/ false","print(3 <= NaN)     \/\/ false","print(NaN <= 3)     \/\/ false","print(NaN <= NaN)   \/\/ false","print(3 > NaN)      \/\/ false","print(NaN > 3)      \/\/ false","print(NaN > NaN)    \/\/ false","print(3 >= NaN)     \/\/ false","print(NaN >= 3)     \/\/ false","print(NaN >= NaN)   \/\/ false","print(3 == NaN)     \/\/ false","print(NaN == 3)     \/\/ false","print(NaN == NaN)   \/\/ false","print(3 != NaN)     \/\/ true","print(NaN != 3)     \/\/ true","print(NaN != NaN)   \/\/ true !!!"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because NaN != NaN is true, sorting a collection of BigDecimal’s doesn’t"},{"type":"text","text":" "},{"type":"text","text":"work if the collection contains one or more NaN’s. This is so, even if"},{"type":"text","text":" "},{"type":"text","text":"BigDecimal conforms to the Comparable protocol. Note: It is possible to"},{"type":"text","text":" "},{"type":"text","text":"sort values including NaNs using the "},{"code":"isTotallyOrdered(belowOrEqualTo:)","type":"codeVoice"},{"type":"text","text":" "},{"text":"method.","type":"text"}]},{"inlineContent":[{"text":"The following example uses ","type":"text"},{"code":"isTotallyOrdered(belowOrEqualTo:)","type":"codeVoice"},{"type":"text","text":" to sort an"},{"type":"text","text":" "},{"text":"array of floating-point values, including some that are NaN:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["var numbers = [2.5, 21.25, 3.0, .nan, -9.5]","numbers.sort { !$1.isTotallyOrdered(belowOrEqualTo: $0) }","print(numbers)","\/\/ Prints \"[-9.5, 2.5, 3.0, 21.25, nan]\""]},{"type":"paragraph","inlineContent":[{"text":"There is a static boolean variable ","type":"text"},{"inlineContent":[{"text":"BigDecimal.NaNFlag","type":"text"}],"type":"emphasis"},{"type":"text","text":" which is set to"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"true","type":"text"}]},{"type":"text","text":" whenever a NaN value is generated. It can be set to "},{"type":"emphasis","inlineContent":[{"type":"text","text":"false"}]},{"text":" by","type":"text"},{"type":"text","text":" "},{"text":"application code. Therefore, to check if a sequence of code generates NaN,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"set NaNFlag to "},{"inlineContent":[{"text":"false","type":"text"}],"type":"emphasis"},{"type":"text","text":" before the code and check it after the code. Since"},{"type":"text","text":" "},{"type":"text","text":"a BigDecimal has a stored property "},{"inlineContent":[{"text":"isNaN","type":"text"}],"type":"emphasis"},{"type":"text","text":", it is of course also possible to"},{"text":" ","type":"text"},{"text":"check for a NaN value at any time.","type":"text"}]},{"anchor":"References","text":"References","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Algorithms from the following books and papers have been used in the implementation."},{"type":"text","text":" "},{"text":"There are references in the source code where appropriate.","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"[GRANLUND] - Moller and Granlund: Improved Division by Invariant Integers, 2011","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"[IEEE] - IEEE Standard for Floating-Point Arithmetic, 2019","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"[KNUTH] - Donald E. Knuth: Seminumerical Algorithms, Addison-Wesley 1971"}]}]}]},{"type":"heading","text":"Acknowledgement","level":2,"anchor":"Acknowledgement"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Much of the original ","type":"text"},{"type":"reference","identifier":"https:\/\/github.com\/leif-ibsen\/BigDecimal.git","isActive":true},{"type":"text","text":" (pre-V2) was created by Leif Ibsen."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Some unit test cases come from the "},{"type":"reference","identifier":"http:\/\/speleotrove.com\/decimal","isActive":true}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Additional unit test cases and some algorithms are from the"},{"text":" ","type":"text"},{"identifier":"https:\/\/www.intel.com\/content\/www\/us\/en\/developer\/articles\/tool\/intel-decimal-floating-point-math-library.html","type":"reference","isActive":true}]}]},{"content":[{"inlineContent":[{"text":"Floating point math functions are translated to Swift from the","type":"text"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/eobermuhlner\/big-math","isActive":true},{"type":"text","text":" implementation by Eric Obermühlner."}],"type":"paragraph"}]}]}]}],"references":{"doc://bigdecimal.BigDecimal/documentation/BigDecimal/SinhCalculator":{"type":"topic","url":"\/documentation\/bigdecimal\/sinhcalculator","role":"symbol","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/SinhCalculator","abstract":[{"type":"text","text":"Calculates hyperbolic sine using the Maclaurin\/Taylor series."}],"kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SinhCalculator","kind":"identifier"}],"navigatorTitle":[{"text":"SinhCalculator","kind":"identifier"}],"title":"SinhCalculator"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/CosCalculator":{"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"CosCalculator","kind":"identifier"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"CosCalculator"}],"type":"topic","abstract":[{"text":"Calculates cosine using the Maclaurin\/Taylor series.","type":"text"}],"role":"symbol","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/CosCalculator","url":"\/documentation\/bigdecimal\/coscalculator","title":"CosCalculator"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/PowerIterator":{"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"PowerIterator","kind":"identifier"}],"title":"PowerIterator","abstract":[],"navigatorTitle":[{"kind":"identifier","text":"PowerIterator"}],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerIterator","url":"\/documentation\/bigdecimal\/poweriterator","role":"symbol","type":"topic","kind":"symbol"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/PowerTwoNPlusOneIterator":{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerTwoNPlusOneIterator","type":"topic","url":"\/documentation\/bigdecimal\/powertwonplusoneiterator","navigatorTitle":[{"text":"PowerTwoNPlusOneIterator","kind":"identifier"}],"abstract":[{"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerIterator","isActive":true},{"text":" to calculate the 2*n+1 term.","type":"text"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"PowerTwoNPlusOneIterator"}],"role":"symbol","kind":"symbol","title":"PowerTwoNPlusOneIterator"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Decimal64":{"kind":"symbol","title":"Decimal64","type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Decimal64"}],"url":"\/documentation\/bigdecimal\/decimal64","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Decimal64","kind":"identifier"}],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal64","abstract":[{"type":"text","text":"Implementation of the 64-bit Decimal64 floating-point operations from"},{"text":" ","type":"text"},{"type":"text","text":"IEEE STD 754-2019 for Floating-Point Arithmetic."}]},"http://speleotrove.com/decimal":{"identifier":"http:\/\/speleotrove.com\/decimal","titleInlineContent":[{"type":"text","text":"General Decimal Arithmetic"}],"type":"link","title":"General Decimal Arithmetic","url":"http:\/\/speleotrove.com\/decimal"},"https://www.intel.com/content/www/us/en/developer/articles/tool/intel-decimal-floating-point-math-library.html":{"identifier":"https:\/\/www.intel.com\/content\/www\/us\/en\/developer\/articles\/tool\/intel-decimal-floating-point-math-library.html","titleInlineContent":[{"text":"Intel C Decimal Floating-Point Math library","type":"text"}],"type":"link","title":"Intel C Decimal Floating-Point Math library","url":"https:\/\/www.intel.com\/content\/www\/us\/en\/developer\/articles\/tool\/intel-decimal-floating-point-math-library.html"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/ExpCalculator":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"ExpCalculator","kind":"identifier"}],"role":"symbol","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/ExpCalculator","navigatorTitle":[{"text":"ExpCalculator","kind":"identifier"}],"url":"\/documentation\/bigdecimal\/expcalculator","abstract":[{"type":"text","text":"Calculates exp using the Maclaurin\/Taylor series."}],"type":"topic","title":"ExpCalculator","kind":"symbol"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/CBDecimal":{"url":"\/documentation\/bigdecimal\/cbdecimal","kind":"symbol","role":"symbol","abstract":[],"title":"CBDecimal","navigatorTitle":[{"kind":"identifier","text":"CBDecimal"}],"type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/CBDecimal","fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"text":"CBDecimal","kind":"identifier"}]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/RoundingRule":{"type":"topic","abstract":[{"type":"text","text":"The rounding modes"}],"role":"symbol","fragments":[{"kind":"keyword","text":"typealias"},{"text":" ","kind":"text"},{"text":"RoundingRule","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"RoundingRule"}],"url":"\/documentation\/bigdecimal\/roundingrule","title":"RoundingRule","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/RoundingRule","kind":"symbol"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/BigDecimal/infinity":{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/infinity","type":"topic","title":"infinity","url":"\/documentation\/bigdecimal\/bigdecimal\/infinity","kind":"symbol","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"let"},{"text":" ","kind":"text"},{"text":"infinity","kind":"identifier"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:10BigDecimalAAV","text":"BigDecimal","kind":"typeIdentifier"}],"abstract":[{"type":"text","text":"BigDecimal(‘Infinity’)"}],"role":"symbol"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/IntRange":{"kind":"symbol","type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/IntRange","url":"\/documentation\/bigdecimal\/intrange","fragments":[{"text":"typealias","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"IntRange"}],"navigatorTitle":[{"kind":"identifier","text":"IntRange"}],"title":"IntRange","role":"symbol","abstract":[]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/BigDecimal/exponent":{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/exponent","abstract":[{"text":"The signed exponent - the value of ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"self","type":"text"}]},{"type":"text","text":" is "},{"type":"emphasis","inlineContent":[{"text":"self.significand","type":"text"}]},{"type":"text","text":" *"},{"text":" ","type":"text"},{"text":"10^","type":"text"},{"type":"emphasis","inlineContent":[{"text":"self.exponent","type":"text"}]}],"title":"exponent","kind":"symbol","role":"symbol","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"exponent"},{"kind":"text","text":": "},{"text":"Int","preciseIdentifier":"s:Si","kind":"typeIdentifier"}],"url":"\/documentation\/bigdecimal\/bigdecimal\/exponent","type":"topic"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/PowerTwoNIterator":{"url":"\/documentation\/bigdecimal\/powertwoniterator","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"PowerTwoNIterator","kind":"identifier"}],"role":"symbol","navigatorTitle":[{"text":"PowerTwoNIterator","kind":"identifier"}],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerTwoNIterator","abstract":[{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerIterator","isActive":true,"type":"reference"},{"text":" to calculate the 2*n term.","type":"text"}],"type":"topic","title":"PowerTwoNIterator","kind":"symbol"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/SeriesCalculator":{"url":"\/documentation\/bigdecimal\/seriescalculator","abstract":[],"role":"symbol","type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/SeriesCalculator","navigatorTitle":[{"kind":"identifier","text":"SeriesCalculator"}],"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"SeriesCalculator"}],"title":"SeriesCalculator"},"https://github.com/leif-ibsen/BigDecimal.git":{"identifier":"https:\/\/github.com\/leif-ibsen\/BigDecimal.git","titleInlineContent":[{"type":"text","text":"BigDecimal"}],"type":"link","title":"BigDecimal","url":"https:\/\/github.com\/leif-ibsen\/BigDecimal.git"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Sign":{"role":"symbol","navigatorTitle":[{"text":"Sign","kind":"identifier"}],"fragments":[{"kind":"keyword","text":"typealias"},{"text":" ","kind":"text"},{"text":"Sign","kind":"identifier"}],"type":"topic","kind":"symbol","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Sign","title":"Sign","url":"\/documentation\/bigdecimal\/sign","abstract":[]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/print(_:separator:terminator:)":{"type":"topic","title":"print(_:separator:terminator:)","role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"print"},{"text":"(","kind":"text"},{"text":"Any","kind":"keyword"},{"kind":"text","text":"..., "},{"text":"separator","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:SS","text":"String","kind":"typeIdentifier"},{"kind":"text","text":", "},{"text":"terminator","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:SS","kind":"typeIdentifier","text":"String"},{"kind":"text","text":")"}],"kind":"symbol","abstract":[{"text":"Need this to intercept CBDecimals printing because the Complex class","type":"text"},{"type":"text","text":" "},{"text":"defines a CustomStringConvertable implementation which cannot","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"be overriden. If file output is needed, also intercept the print"},{"type":"text","text":" "},{"text":"function with the “to: inout Target” as the last parameter.","type":"text"}],"url":"\/documentation\/bigdecimal\/print(_:separator:terminator:)","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/print(_:separator:terminator:)"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/BigDecimal":{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"BigDecimal","kind":"identifier"}],"kind":"symbol","navigatorTitle":[{"text":"BigDecimal","kind":"identifier"}],"role":"symbol","type":"topic","title":"BigDecimal","abstract":[{"text":"A signed decimal value of unbounded precision (actually there is a","type":"text"},{"text":" ","type":"text"},{"text":"practical limit defined by ","type":"text"},{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/maxDigits","isActive":true,"type":"reference"},{"type":"text","text":" of 200 that the user can change)."},{"type":"text","text":" "},{"type":"text","text":"A "},{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal","isActive":true,"type":"reference"},{"text":" value is represented as a signed ","type":"text"},{"type":"codeVoice","code":"BInt"},{"text":" significand","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and a signed "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" exponent that is limited to ten digits."},{"type":"text","text":" "},{"type":"text","text":"The value of a Self is "},{"isActive":true,"type":"reference","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/digits"},{"type":"text","text":" * 10^"},{"isActive":true,"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/exponent","type":"reference"},{"type":"text","text":"."}],"url":"\/documentation\/bigdecimal\/bigdecimal"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/RawDecimal":{"abstract":[],"type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/RawDecimal","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"RawDecimal","kind":"identifier"}],"kind":"symbol","title":"RawDecimal","url":"\/documentation\/bigdecimal\/rawdecimal","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"RawDecimal"}]},"https://github.com/eobermuhlner/big-math":{"identifier":"https:\/\/github.com\/eobermuhlner\/big-math","titleInlineContent":[{"text":"Java BigDecimalMath","type":"text"}],"type":"link","title":"Java BigDecimalMath","url":"https:\/\/github.com\/eobermuhlner\/big-math"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Decimal32":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"Decimal32","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal32","title":"Decimal32","kind":"symbol","url":"\/documentation\/bigdecimal\/decimal32","abstract":[{"type":"text","text":"Implementation of the 32-bit Decimal32 floating-point operations from"},{"type":"text","text":" "},{"type":"text","text":"IEEE STD 754-2019 for Floating-Point Arithmetic."}],"navigatorTitle":[{"text":"Decimal32","kind":"identifier"}],"role":"symbol"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/ComplexModule":{"abstract":[],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/ComplexModule","title":"ComplexModule","type":"topic","kind":"symbol","url":"\/documentation\/bigdecimal\/complexmodule","role":"collection"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Decimal":{"type":"topic","kind":"symbol","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal","url":"\/documentation\/bigdecimal\/decimal","abstract":[{"text":"Implementation of a clone of Apple’s Decimal floating-point data type","type":"text"},{"text":" ","type":"text"},{"text":"using ","type":"text"},{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal","type":"reference","isActive":true},{"text":" operations.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Decimal"}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Decimal"}],"title":"Decimal"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Rounding":{"url":"\/documentation\/bigdecimal\/rounding","navigatorTitle":[{"kind":"identifier","text":"Rounding"}],"abstract":[{"type":"text","text":"BigDecimal rounding object containing a rounding mode and a precision"},{"type":"text","text":" "},{"text":"which is the number of digits in the rounded result","type":"text"}],"type":"topic","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Rounding"}],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Rounding","title":"Rounding","role":"symbol"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/PowerNIterator":{"url":"\/documentation\/bigdecimal\/powerniterator","title":"PowerNIterator","abstract":[],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"PowerNIterator"}],"navigatorTitle":[{"text":"PowerNIterator","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/PowerNIterator","kind":"symbol","role":"symbol"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Swift":{"abstract":[],"title":"Swift","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Swift","type":"topic","kind":"symbol","url":"\/documentation\/bigdecimal\/swift","role":"collection"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/CoshCalculator":{"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/CoshCalculator","navigatorTitle":[{"kind":"identifier","text":"CoshCalculator"}],"url":"\/documentation\/bigdecimal\/coshcalculator","role":"symbol","abstract":[{"type":"text","text":"Calculates hyperbolic cosine using the Maclaurin\/Taylor series."}],"title":"CoshCalculator","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"CoshCalculator"}],"type":"topic"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Decimal128":{"type":"topic","abstract":[{"type":"text","text":"Implementation of the 128-bit Decimal128 floating-point operations from"},{"text":" ","type":"text"},{"text":"IEEE STD 754-2019 for Floating-Point Arithmetic.","type":"text"}],"role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Decimal128","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"Decimal128"}],"url":"\/documentation\/bigdecimal\/decimal128","title":"Decimal128","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Decimal128","kind":"symbol"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/BigDecimal/maxDigits":{"fragments":[{"text":"static","kind":"keyword"},{"kind":"text","text":" "},{"kind":"keyword","text":"let"},{"text":" ","kind":"text"},{"kind":"identifier","text":"maxDigits"},{"text":": ","kind":"text"},{"text":"Int","preciseIdentifier":"s:Si","kind":"typeIdentifier"}],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/maxDigits","kind":"symbol","title":"maxDigits","url":"\/documentation\/bigdecimal\/bigdecimal\/maxdigits","role":"symbol","abstract":[],"type":"topic"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/AsinCalculator":{"navigatorTitle":[{"text":"AsinCalculator","kind":"identifier"}],"title":"AsinCalculator","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"AsinCalculator"}],"kind":"symbol","type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/AsinCalculator","url":"\/documentation\/bigdecimal\/asincalculator","abstract":[{"text":"Calculates arcsine using the Maclaurin\/Taylor series.","type":"text"}]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/Status":{"navigatorTitle":[{"kind":"identifier","text":"Status"}],"identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/Status","type":"topic","role":"symbol","title":"Status","url":"\/documentation\/bigdecimal\/status","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Status","kind":"identifier"}],"kind":"symbol","abstract":[]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/BigDecimal/digits":{"fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"digits"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:6BigInt4BIntV","text":"BInt","kind":"typeIdentifier"}],"role":"symbol","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/BigDecimal\/digits","url":"\/documentation\/bigdecimal\/bigdecimal\/digits","abstract":[{"type":"text","text":"The signed BInt significand"}],"type":"topic","title":"digits","kind":"symbol"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/DecimalFloatingPoint":{"title":"DecimalFloatingPoint","type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/DecimalFloatingPoint","abstract":[{"type":"text","text":"A radix-10 (decimal) floating-point type."}],"role":"symbol","url":"\/documentation\/bigdecimal\/decimalfloatingpoint","navigatorTitle":[{"kind":"identifier","text":"DecimalFloatingPoint"}],"kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"kind":"identifier","text":"DecimalFloatingPoint"}]},"doc://bigdecimal.BigDecimal/documentation/BigDecimal/SinCalculator":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SinCalculator","kind":"identifier"}],"navigatorTitle":[{"text":"SinCalculator","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal\/SinCalculator","abstract":[{"type":"text","text":"Calculates sine using the Maclaurin\/Taylor series."}],"url":"\/documentation\/bigdecimal\/sincalculator","kind":"symbol","role":"symbol","title":"SinCalculator"},"doc://bigdecimal.BigDecimal/documentation/BigDecimal":{"abstract":[{"text":"The BigDecimal package provides arbitrary-precision (with an adjustable upper","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"limit for performance) and fixed-precision decimal arithmetic in Swift."}],"title":"BigDecimal","type":"topic","identifier":"doc:\/\/bigdecimal.BigDecimal\/documentation\/BigDecimal","url":"\/documentation\/bigdecimal","role":"collection","kind":"symbol"}}}